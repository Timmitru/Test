with open ('27_B.txt') as f: #Считываем сам файл
    n = int(f.readline()) # Считываем количество чисел
    sm = 0 #Переменная для подсчета суммы считаных чисел
    a = [] #Массив для всех считанных чисел

    for i in f:
        a.append(int(i)) # Записываем все числа в массив
        sm = sm + int(i) # Cуммируем все элементы в sm


le = sm % 89 # Найдём на сколько наша получившаяся сумма больше, чем ближайшее число которое делится на 89

count = 0 # Переменная для количества элементов, которые нужно отнять от всей суммы для получения суммы адаптированной под условия задачи

#1 часть проверяем сколько минимум элементов нужно убрать из начала последовательности для получения необходимой суммы
sm1 = 0 #Сумма для первой части
k1 = 0 #Количество элементов для первой части

for i in range(0, n):
    sm1 = sm1 + a[i] #Добавляем по одному элементу из последовательности
    k1 = k1 + 1 #И сразу считаем их количество
    if sm1 % 89 == le: #Делаем проверку, если условие выполнено, то останавливаемся
        break

#2 часть проверяем сколько минимум элементов нужно убрать из конца последовательности для получения необходимой суммы
sm2 = 0 #Сумма для второй части
k2 = 0 #Количество элементов для второй части
for i in range(n - 1, -1, -1):
    sm2 = sm2 + a[i] #Добавляем по одному элементу из последовательности
    k2 = k2 + 1 #И сразу считаем их количество
    if sm2 % 89 == le: #Делаем проверку, если условие выполнено, то останавливаемся
        break

#3 Часть выбираем более оптимальный вариант, с наибольшей сохранённой суммой
if sm1 < sm2: #Сравниваем суммы и сохраняем подходящую
    mn = sm1
    count = k1
else:
    mn = sm2
    count = k2

if sm1 == sm2: #Рассматриваем ситуацию, когда суммы оказалиь равны, в этом случе необходимо произвести по очереди удаление элементов с разных концов последовательности, для начала отталкиваемся от одного из начала и остальных с конца итд
    count = max(k1, k2)

sm3_1 = 0

k3_1 = 0
k3_2 = 0

for i in range(0, n):
    if sm3_1 > mn: break
    sm3_1 = sm3_1 + a[i]
    k3_1 = k3_1 + 1

    k3_2 = 0
    sm3_2 = 0

    for j in range(n - 1, -1, -1):
        sm3_2 = sm3_2 + a[j]
        k3_2 = k3_2 + 1
        if (sm3_1 + sm3_2) % 89 == le:
            if (sm3_1 + sm3_2) < mn:
                mn = sm3_1 + sm3_2
                count = k3_1 + k3_2

            if sm3_1 + sm3_2 == mn:
                count = max(count, k3_1 + k3_2)

            break

#4 Часть аналогично 3ей части, только меняем начало и конец местами для поиска оптимального варианта
sm4_1 = 0

k4_1 = 0
k4_2 = 0

for i in range(n - 1, -1, -1):
    if sm4_1 > mn: break
    sm4_1 = sm4_1 + a[i]
    k4_1 = k4_1 + 1

    k4_2 = 0
    sm4_2 = 0

    for j in range(0, n):
        sm4_2 = sm4_2 + a[j]
        k4_2 = k4_2 + 1
        if (sm4_1 + sm4_2) % 89 == le:
            if (sm4_1 + sm4_2) < mn:
                mn = sm4_1 + sm4_2
                count = k4_1 + k4_2

            if sm4_1 + sm4_2 == mn:
                count = max(count, k4_1 + k4_2)

            break

# Делаем последнюю основную проверку и печатаем наш ответ в зависимости от того подошла нам 3 или 4 часть
if le == 0:
    print(n)
else:
    print(n - count)